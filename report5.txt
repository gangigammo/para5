--------------------------

学籍番号 : 16B16163
氏名 : 吉川純平

--------------------------

回答1 :
1.1) 空欄に入る数は以下のとおり

A：16777216(=256^3)

B: 64

C: 64

1.2)
並列化で問題となるStreamの処理の番号
1番目



1.3)単純に並列化したのでは結果が異なる原因
ave.get(label).add(inimage[n])は、aveの各r,g,bの値を加算していくものであるので、競合し、値が
定まらなくなってしまうから。






1.4)並列化に対応するために行った変更点
aveの計算をsynchronizedすることで、aveの各r,g,bの加算をそれぞれ終了するまで
aveの値の変更を許さないようにした。




回答2 :
2.1)
出力される時間の意味
100単位分の玉の運動の計算にかかった時間

Single 10回
48213 48413 50477 48413 48388 48325 49244 49039 49176 49132
Parallel 10回
30862 30600 30707 32912 31031 30681 30901 30786 31108 30835


達成された高速化の数値的説明
Single 48882 msec
Parallel 31042 msec
これらより、17840 msec つまり36%の高速化された。


計測時間の信頼性を向上させるために行った工夫、計測で注意した点
起動中のプロセスにより計測時間のばらつきが生じるので、使用しない
アプリを全て起動せずに、対照的な計測を行った。



2.2)
衝突判定部分の高速化についてのjvisualvmを使用した調査方法の説明
CollisionCheckerParallel2のセルフ・タイムで比較した。





調査により判明した衝突判定部分の高速化前後の処理速度の比率
CollisionCheckerParallel2
Single 28990msec
Parallel 3397msec
より、8.53倍になった。





2.3)
発見された改善対象のコード部分
ShapeManager.remove()




改良方針
ShapeManager.remove()内の
data.idがidと一致するかを、並列化して判定し、そのShapeを保存し、もし一致するものがあれば、
並列処理が終了してからそのShapeをremoveした後にtrueを、もしなければfalseを返すようにした。




2.4)2.3で行った改良部分の改良前後の処理時間について

処理時間の定義
ShapeManager.remove()の実際にかかる処理時間を表すセルフ・タイムの値で比較した。

12030msec -> 8286msec


改良前と比べ改良後の処理時間は　　68.9　　％となった



回答3 :
3.1)ゲーム性を高めるための実装
得点ルールの定義
壊したピンクの的の個数を点数scoreにした。



得点計算のコード部分について
Game03の118行目で、ピンクの的と玉の衝突判定によりインクリメントしている。



得点表示のためのコード部分について
Game03の56~58行目と119~121行目で、scoreの各位を出力している。



ゲームの終了条件の定義
ボールが受け皿より下に落ちたら終了させている。



ゲームの終了判定のコード部分について
ボールと壁との衝突判定時にボールの位置受け皿の位置を比較し終了させている。




スタートボタンを押した際の新たな初期化処理について
古いthreadによるゲームが終了した場合のみ新たに初期化している。





ゲームの難易度の方針
ボールの速さと受け皿の速さを難易度倍している。




数値選択とゲーム難易度についての実装部分について
spinner.getValue()の値であるGame03の35行目の引数を用いている。





3.2)さらなるゲーム性を高めるための実装
実装方針
ボールを受け皿が受けるとき、受け皿が右向きに動いているときに、ボールの速さを右に少し足し、
また左の場合も同様にする。



実装箇所
Game03の110行目から114行目



今回の課題で特に学べたと感じたこと
スレッドセーフであるかの判断
